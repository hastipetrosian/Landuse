---
title: "Cross validation"
---

```{r packages}
library(tidyverse) ## load filter(), ... function
library(blockCV)
library(sf)
library(raster)
library(ggplot2)
library(shiny) ## what for ... ??
library(ROSE)
library(caret)
source("functions.R")
library(randomForest)
```
To knit "by hand", `rmarkdown::render("Cross_validation.Rmd")`
```{r input_data}
## increase memory
if (.Platform$OS.type=="windows") memory.limit(1000000)

## get all data (as tables of x,y, predictors, change)
load("rr_points14.RData")

## test with smaller data set
dat <- dplyr::filter(rr_points14[["2014"]],
                     x<604000 & y >284000 &  y < 2846000)
dat$change2 <- change_fun(dat$change)
```

```{r upsample}
dat_gain <- dplyr::filter(dat, change2 %in% c("no gain", "gain")) 

## analyzing gain only, first ...
if (file.exists("dat_upsample")) {
    load("dat_upsample")
}  else {
    dat_upsample <- ROSE::ovun.sample(change ~ ., data = dat_gain, method = "both", N=1500)$data
}
```

```{r classified_maps}
Classified1=raster("Classified1.tif")
Classified2=raster("classified2.tif")
```
The appropriate format of species data for the blockCV package is simple features (sf) or SpatialPointsDataFrame.pamake a SpatialPointsDataFrame object from data.frame
```{r numeric_data}
PA_data <- st_as_sf(dat_upsample, coords = c("x", "y"), crs = crs(Classified1))
```

```{r train_vs_test}
set.seed(23489)
train_index <- sample(1:nrow(PA_data), 0.9 * nrow(dat_upsample))
sample_train <- PA_data[train_index, ]
sample_test  <- PA_data[-train_index, ]
```
Spatial blocking by specified range with random assignment
creates spatially separated folds based on a pre-specified distance (cell size of the blocks).
```{r spatial_blocking, cache=TRUE}
sb <- spatialBlock(speciesData = PA_data,
                   species = "change2",
                   rasterLayer = Classified1,
                   ## theRange = 70000, # size of the blocks
                   theRange = 5000, # size of the blocks                   
                   k = 5,
                   selection = "random",
                   iteration = 100, # find evenly dispersed folds
                   biomod2Format = TRUE,
                   xOffset = 0, # shift the blocks horizontally
                   yOffset = 0)
## select *first* (training) set of indices for each fold
## IS THIS THE RIGHT WAY TO DO THIS ???
trainfoldsb <- lapply(sb$folds, function(x) x[[1]])
traincontrolsb <- caret::trainControl(index = trainfoldsb,method="CV")
```
specify sets of similar environmental conditions based on the input covariates. Species data corresponding to any of these groups or clusters are assigned to a fold.
```{r envBlock}
eb <- envBlock(rasterLayer = Classified1,
               speciesData = PA_data,
               species = "change2",
               k = 5,
               standardization = "standard", # rescale variables between 0 and 1
               rasterBlock = FALSE,
               numLimit = 50)
trainfoldeb <- lapply(eb$folds, function(x) x[[1]])
traincontrolsb <- caret::trainControl(index = trainfoldeb,method="CV")
```
generates spatially separated training and testing folds by considering buffers of specified distance around each observation point. 

```{r buffering, cache=TRUE}
bf <- buffering(speciesData = PA_data,
                  theRange = 1000,#ideally the range of spatial autocorrelation
                  species = "change2", # to count the number of presences and absences/backgrounds
                  spDataType = "PA", # presence-absence  data type
                  progress = TRUE)
```

```{r plot_buffer}
dd1 <- bf$folds[[1]] ## first fold
## training data
plot(y~x, data=dat_upsample[dd1[[1]],])  
## testing data
## data points that aren't in test or in train
excluded <- setdiff(seq(nrow(dat_upsample)), c(dd1[[1]],dd1[[2]]))
##plot
with(dat_upsample[excluded,], points(x,y,col=4))
with(dat_upsample[dd1[[2]],], points(x,y,col=2,pch=16,cex=2))
```

```{r plot_buffer_2}
##not convenience
ctr <- list(x=601023, y=2844924)  ## a focal point
dist_to_ctr <- sqrt((dat_upsample$x-ctr$x)^2 + (dat_upsample$y-ctr$y)^2)
pts <- seq(nrow(dat_upsample))
test <- pts[dist_to_ctr<1000]
excluded <- pts[dist_to_ctr>1000 & dist_to_ctr<2000]
train <- pts[dist_to_ctr>2000]
plot(y~x,data=dat_upsample[train,])
grid(nx=4,ny=4,col=5)
with(dat_upsample[excluded,], points(x,y,col=4))
with(dat_upsample[test,], points(x,y,col=2,pch=16))
```


```{r random_forest_buffer1}
# extract the folds (list)SpatialBlock object 
folds <- bf$folds
fvec <- seq_len(length(folds))
for (k in fvec) {
    ## extracting the training and testing indices
    ## this way works with folds list (but not foldID)
    trainSet <- unlist(folds[[k]][1]) # training set indices
    testSet <- unlist(folds[[k]][2]) # testing set indices
}
## BMB: when this finishes, we have
trainSet <- unlist(folds[[1500]][1])
testSet <- unlist(folds[[1500]][2])

## if you want to run the rf for lots of folds
## rf_list <- list()
## for (k in 1:nfolds) {
##    ## extract train set
##    ## run rf on train set
##    rf_list[[k]] <- ## random forest model you just fitted
## }
## if you have 10 folds, this will save 10 fitted random forest models

## aucvec <- rep(NA,nfolds)
## for (k in 1:nfolds) {
##   get test set data for fold k
##   get predictions from rf_list[[k]]
##   pp <- pROC::roc
##   aucvec[k] <- c(pp$auc)
## }
## mean(aucvec)
##
## averaging the ROC curves is harder ...


a <- PA_data[trainSet,]
a$geometry <- NULL
b <- PA_data[testSet, ]
b$geometry <- NULL
rfcv <- randomForest(formula= factor(change2) ~ .  - landuse - change,
                       data = a, n.trees=250,interaction.depth=7,
                       ## do.trace=1,
                     type="classification", proximity=TRUE) # model fitting on training set
## test set is only 1 point
predcv<- predict(rfcv, newdata=b, type = "prob")
head(predcv)
```
H-P:Error in predcv[, "gain"] : subscript out of bounds
```{r roc_random_forest_buffer1}
rocCurve <- pROC::roc(factor(b$change2,levels=c("gain","nogain")),
                      predcv[,"gain"])

pp <- pROC::roc(sample(0:1,size=50,replace=TRUE), pred=runif(50))
plot(pp)
plot(pROC::roc(c(1,1,0,0), pred=c(0.2,0.4,0.1,0.2)))
plot(pROC::roc(c(1,0), pred=c(0.2,0.2)))


plot(rocCurve ,col=c(4))
###calculate the area under curve (bigger is better)
auc(rocCurve)
```
may be this method is not coorect for cross validation
```{r random_forest_sbfolds}
rf_sb=train(as.factor(change2) ~ .,
              data = dat_upsample, ## use the same data here as we used in spatialBlock()?
              method = "ranger",
              trControl = traincontrolsb)

rf_predsb <- predict(rf_sb, sample_test)
consb=confusionMatrix(rf_predsb, as.factor(sample_test$change2))
```
hP=index` should be lists of integers.
adding points on saptialBlock plot
```{r random_forest_ebfolds}
rf_eb=train(as.factor(change2) ~ .,
              data = dat_upsample, ## use the same data here as we used in spatialBlock()?
              method = "ranger",
              trControl = traincontroleb)

rf_predeb <- predict(rf_eb, sample_test)
coneb=confusionMatrix(rf_predeb, as.factor(sample_test$change2))
```

```{r plot}
sb$plots + geom_sf(data = PA_data, alpha = 0.5)
```
visualising the generated folds on a map
```{r folds_in_spatialk}
fold=foldExplorer(eb, Classified1, PA_data)
print(fold)
```
buffer 3
```{r determine_data}
##introsucing the specific block 
corners <- list(x=c(598503.1,601478.4),
                y=c(2842969,2839900))
pts <- seq(nrow(dat_upsample))
##introducinf test data in the introduced block
test <- pts[dat_upsample$x > corners$x[1] &
            dat_upsample$x < corners$x[2] &
            dat_upsample$y < corners$y[1] &
            dat_upsample$y > corners$y[2]]

##setdiff indicates which elements of a vector or data frame X are not existent in a vector or data frame Y.
train <- setdiff(pts,test)
plot(y~x,data=dat_upsample[train,])
grid(nx=4,ny=4,col=5)
with(dat_upsample[test,], points(x,y,col=2,pch=16))
```
determine train and test data 
```{r train_testdata}
umFolds <- trainControl(method = "cv", number = 10)
a <- PA_data[train,]
b <- PA_data[test, ]
a$geometry <- NULL
b$geometry <- NULL
rf_b=train(as.factor(change2) ~ .  - landuse - change,
            data = a, ## use the same data here as we used in spatialBlock()?
            method = "ranger",
            trControl = umFolds)
plot(rf_b)
pred_b=predict(rf_b, newdata=b, typeprobs="prob")
conb=confusionMatrix(pred_b, as.factor(b$change2))
table(b$change2, pred_b)

```
H-P:Error in ROC
```{r ROC_Curve}
rocCurve <- pROC::roc(factor(b$change2,levels=c("gain","nogain")),
                      pred_b[,"gain"])

pp <- pROC::roc(sample(0:1,size=50,replace=TRUE), pred=runif(50))
plot(pp)
plot(pROC::roc(c(1,1,0,0), pred=c(0.2,0.4,0.1,0.2)))
plot(pROC::roc(c(1,0), pred=c(0.2,0.2)))


plot(rocCurve ,col=c(4))
###calculate the area under curve (bigger is better)
auc(rocCurve)
```


