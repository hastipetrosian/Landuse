---
title: "Cross validation"
---

```{r packages}
library(tidyverse) ## load filter(), ... function
library(blockCV)
library(sf)
library(raster)
library(ggplot2)
library(shiny) ## what for ... ??
library(ROSE)
library(caret)
source("functions.R")
```
To knit "by hand", `rmarkdown::render("Cross_validation.Rmd")`
```{r input_data}
## increase memory
if (.Platform$OS.type=="windows") memory.limit(1000000)

## get all data (as tables of x,y, predictors, change)
load("rr_points14.RData")

## test with smaller data set
dat <- dplyr::filter(rr_points14[["2014"]],
                     x<604000 & y >284000 &  y < 2846000)
dat$change2 <- change_fun(dat$change)
```

```{r upsample}
dat_gain <- dplyr::filter(dat, change2 %in% c("no gain", "gain")) 

## analyzing gain only, first ...
if (file.exists("dat_upsample")) {
    load("dat_upsample")
}  else {
    dat_upsample <- ROSE::ovun.sample(change ~ ., data = dat_gain, method = "both", N=1500)$data
}
```

```{r classified_maps}
Classified1=raster("Classified1.tif")
Classified2=raster("classified2.tif")
```
make a SpatialPointsDataFrame object from data.frame
```{r numeric_data}
PA_data <- st_as_sf(dat_upsample, coords = c("x", "y"), crs = crs(Classified1))
```
Spatial blocking by specified range with random assignment
```{r spatial_blocking, cache=TRUE}
sb <- spatialBlock(speciesData = PA_data,
                   species = "change2",
                   rasterLayer = Classified1,
                   ## theRange = 70000, # size of the blocks
                   theRange = 5000, # size of the blocks                   
                   k = 5,
                   selection = "random",
                   iteration = 100, # find evenly dispersed folds
                   biomod2Format = TRUE,
                   xOffset = 0, # shift the blocks horizontally
                   yOffset = 0)
## select *first* (training) set of indices for each fold
## IS THIS THE RIGHT WAY TO DO THIS ???
trainfolds <- lapply(sb$folds, function(x) x[[1]])
traincontrolsb <- caret::trainControl(index = trainfolds,method="CV")
```

```{r envBlock}
eb <- envBlock(rasterLayer = Classified1,
               speciesData = PA_data,
               species = "change2",
               k = 5,
               standardization = "standard", # rescale variables between 0 and 1
               rasterBlock = FALSE,
               numLimit = 50)
traincontroleb=trainControl(index = eb,method="CV")
```

```{r train_vs_test}
set.seed(23489)
train_index <- sample(1:nrow(dat_upsample), 0.9 * nrow(dat_upsample))
sample_train <- dat_upsample[train_index, ]
sample_test  <- dat_upsample[-train_index, ]
```

```{r random_forest_sbfolds}
rf_sb=train(as.factor(change2) ~ .,
              data = dat_upsample, ## use the same data here as we used in spatialBlock()?
              method = "ranger",
              trControl = traincontrolsb)

rf_predsb <- predict(rf_sb, sample_test)
consb=confusionMatrix(rf_predsb, as.factor(sample_test$change2))
```
hP=index` should be lists of integers.
adding points on saptialBlock plot
```{r random_forest_ebfolds}
rf_eb=train(as.factor(change2) ~ .,
              data = dat_upsample, ## use the same data here as we used in spatialBlock()?
              method = "ranger",
              trControl = traincontroleb)

rf_predeb <- predict(rf_eb, sample_test)
coneb=confusionMatrix(rf_predeb, as.factor(sample_test$change2))
```

```{r plot}
sb$plots + geom_sf(data = PA_data, alpha = 0.5)
```
visualising the generated folds on a map

```{r folds_in_spatialk}
fold=foldExplorer(eb, Classified1, PA_data)
print(fold)
```

